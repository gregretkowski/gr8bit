/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module toy_counter (
  input clk,
  input in,
  output out_1,
  output out_2,
  output out_3,
  output out_4,
  output out_5,
  output out_6
);
  wire s0;
  wire [5:0] s1;
  wire s2;
  DIG_Counter_Nbit #(
    .Bits(3)
  )
  DIG_Counter_Nbit_i0 (
    .en( 1'b1 ),
    .C( clk ),
    .clr( 1'b0 ),
    .ovf( s2 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( in ),
    .C( s2 ),
    .Q( s0 )
  );
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i2 (
    .en( s0 ),
    .C( clk ),
    .clr( 1'b0 ),
    .out( s1 )
  );
  assign out_1 = s1[0];
  assign out_2 = s1[1];
  assign out_3 = s1[2];
  assign out_4 = s1[3];
  assign out_5 = s1[4];
  assign out_6 = s1[5];
endmodule
